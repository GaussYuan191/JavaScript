<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手写js</title>
</head>
<body>
    <script>
    var log = console.log
    // JavaScript 基础
    // 1.手写 Object.create
    // 思路：将传入的对象最为原型
 
    // function newCreate (obj) {
    //     function F() {}
    //     F.prototype = obj;
    //     return new F();
    // } 
    // log('原生', Object.create(Array))
    // log('手写', newCreate(Array))
    // 2.手写instanceof
    // 获取类型的原型 获取对象的原型 循环判断对象的原型和类型的原型，是否相等
    // function myInstanceof(left, right) {
    //     let proto = Object.getPrototypeOf(left) //获取对象的原型
    //     let prototype = right.prototype;  //获取构造函数的prototype 对象
    //     log(proto, prototype)
    //     //判断构造函数的prototype 对象是否在对象的原型链上
    //     while (true) {
    //         if (!proto) return false;
    //         if (proto === prototype) return true;
    //         // proto = Object.getPrototypeOf(proto);

    //         proto = proto.__proto__
    //     }
        
    // }
    // log(myInstanceof(new Array, Array))
    // log(new Array instanceof Array)
    // 3.手写new 操作符
    // 在调用new的过程中会发生以下四件事
    // a:创建一个空对象
    // b:设置原型，将对象的原型设置成函数的prototype对象
    // c:让函数的this指向这个对象，执行构造函数的代码(为这个新对象添加属性)
    // d:判断函数的返回值类型，如果是值的类型，返回创建的对象。如果是引用类型，就返回引用类型
    // function objectFactory() {
    //     log (arguments)
    //     let newObj = null;
    //     let constructor = Array.prototype.shift.call(arguments);
    //     let result = null;
    //     log (constructor)
    //     // 判断参数是否为一个函数
    //     if (typeof constructor !== 'function') {
    //         throw new Error("type error")
    //         return;
    //     }
    //     // 创建一个空对象，对象的原型为构造函数的prototype 对象
    //     newObject = Object.create(constructor.prototype);
    //     // 将this指向新建对象，并执行函数
    //     result = constructor.apply(newObj, arguments)
    //     // 判断返回的对象
    //     let flag = result && (typeof result === "object" || typeof result === 'function');
    //     // 判断返回的结果
    //     return flag ? result : newObj;
    // }
    // log (objectFactory(String))
    // 手写promise
    // const pending = 'pending';
    // const fulfilled = 'fulfilled';
    // const reject = 'reject';
    // function MyPromise(fn) {
    //     // 保存初始化状态
    //     var self = this;
    //     // 初始化状态
    //     this.state = pending;
    //     // 初始化结果
    //     this.value = null;
    //     // 用于保存resolve的回调函数
    //     this.resolvedCallbacks = [];
    //     // 用于保存reject的回调函数
    //     this.rejectedCallbacks = [];
    //     // resolve 方法
    //     function resolve (value) {
    //         // 判断传入的元素是否为promise值，如果是，则状态改变必需等待前一个状态改变后再进行改变
    //         if (value instanceof MyPromise) {
    //             return value.then(resolve, reject);
    //         }
    //         // 保证代码的执行顺序为本轮事件循环的末尾
    //         setTimeout(() => {
    //             if (self.state === pending) {
    //                 // 改变状态
    //                 self.value = fulfilled;
    //                 // 设置传入的值
    //                 self.value = value;
    //                 // 执行回调函数
    //                 self.resolvedCallbacks.forEach( callback => callback(value));

    //             }
    //         },0);
    //     }
    //     // reject 方法
    //     function reject (value) {
    //         // 保证代码的执行顺序为本轮事件循环的末尾
    //         setTimeout(() => {
    //             if (self.state === pending) {
    //                 // 改变状态
    //                 self.state = reject;
    //                 // 设置传入的值
    //                 self.value = value;
    //                 // 执行回调函数
    //                 self.rejectedCallbacks.forEach( callback => callback(value));
    //             }
    //         }, 0);
    //     }
    //     try {
    //         fn(resolve, reject);
    //     } catch (e) {
    //         // 遇到错误，捕获错误，执行reject函数
    //         reject(e);
    //     }
    // }
    // MyPromise.prototype.then = function (onResolved, onRejected) {
    //     // 首先判断两个参数是否为函数类型，因为这两个参数是可选的
    //     onResolved = typeof onResolved === 'function' ? onResolved : () => {};
    //     onRejected = typeof onRejected === 'function' ? onRejected : () => {};
    //     // 如果状态是等待状态，则将函数进入对应的列表中
    //     if (this.state === pending) {
    //         this.resolvedCallbacks.push(onResolved);
    //         this.rejectedCallbacks.push(onRejected);

    //     }
    //     if (this.state === fulfilled) {
    //         onResolved(this.value);
    //     }
    //     if (this.state === reject) {
    //         onRejected(this.value);
    //     }
    // }
    // log(1)
    // let p = new MyPromise((resolve, reject) => {
    //     setTimeout(() => {
    //         resolve(2);
    //     }, 1000)
    // })
    // setTimeout(() => {
    //     log(3)
    // })
    // p.then()
    // 6.手写Promise.all
    // 核心思路
    // 1.接收一个promise实例的数据或具有iterator接口的对象作为参数
    // 2.这个方法返回一个新数的promise对象
    // 3.遍历传入的参数，用Promise.resolve()将参数"包一层"，使其变成一个promise对象
    // 4.参数所有回调成功才算成功，返回值数组与参数顺序一致
    // 5.参数数组中有一个失败，则触发失败，第一个触发失败的promise错误信息作为promise.all的错误信息
    function promiseAll (promises) {
        return new Promise((resolve, reject) => {
            // 先判断参数类型
            if (!Array.isArray(promises)) {
                throw new TypeError(`argument must be a array`);
            }
            var resolvedResult = [];
            var resolvedCount = 0;
            var resolvedNum = promises.length;
            for (let i = 0; i < resolvedNum; i++) {
                log(promises[i])
                Promise.resolve(promises[i]).then(value => {
                    resolvedCount++;
                    log(value)
                    resolvedResult.push(value);
                    if (resolvedCount == resolvedNum) {
                        return resolve(resolvedResult);
                    }
                }, error => {
                    return reject(error);
                })
            }
        })
    } 
    // Promise.race() 接收一个promise对象的数组作为参数，并返回一个新的promise对象
    // 数组中有一个对象最早改变状态(resolve, reject)时，就改变自身的状态,并执行响应回调
    function promiseRace (promises) {
        // 类型必需是数组类型
        if (!Array.isArray(promises)) {
            throw new TypeError(`argument must be a array`)
        }
        return new Promise((resolve, reject) => {
            promises.forEach( p => {
                Promise.resolve(p).then( value => {
                    resolve(value);
                }, error => {
                    reject(error);
                })
            })
        })
    }
    // test 
    let p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(1);
        }, 4000);
    })
    let p2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(2);
        }, 2000);
    })
    let p3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(3);
        }, 3000);
    })
    // promiseAll([1, 2, 3]).then(res => {
    //     log(res);
    // })
    // Promise.all([1, 2, 3]).then(res => {
    //     log(res);
    // })
    promiseRace(new Set(1, 2, 3)).then( res => {
        log(res);
    })
    Promise.race(new Set(1, 2, 3)).then( res => {
        log(res);
    })
    // 数据处理
    // 1.实现日期格式化函数
    //     const dateFormat = (dateInput, format)=>{
    //     var day = dateInput.getDate() 
    //     var month = dateInput.getMonth() + 1  
    //     var year = dateInput.getFullYear()   
    //     format = format.replace(/yyyy/, year)
    //     format = format.replace(/MM/,month)
    //     format = format.replace(/dd/,day)
    //     return format
    // }
    // log(dateFormat(new Date('2020-12-01'), 'yyyy/MM/dd')) // 2020/12/01
    // dateFormat(new Date('2020-04-01'), 'yyyy/MM/dd') // 2020/04/01
    // log(dateFormat(new Date('2020-04-01'), 'yyyy年MM月dd日')) // 2020年04月01日
    </script>
</body>
</html>